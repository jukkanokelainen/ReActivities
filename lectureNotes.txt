valmistelu:
asennetaan toki
-node.js
-.net sdk 5.0.4
vs code lisäosat:
  -c# (pakollinen)
  -c# extensions (v1.4.2)
  -nuget gallery
  -material icon theme
  -sqlite käytetään fronfin devauksessa tietokannan sijasta. 
  tämä extension mahdollistaa tietokannan sisällön katselun

projektin lähdekoodi löytyy:
https://github.com/TryCatchLearn/Reactivities

ALKAA:
luodaan dotnet projekti (API)
cmd:ssä mennään reactivities-kansioon
dotnet new sln
 -> tämä loi tiedoston reactivities.sln
dotnet new webapi -n API
 -> tämä loi API-kansion ja sinne webapi-templaten mukaiset tiedostot
dotnet new classlib -n Application
 -> tämä loi Application-kansion ja sinne classlib-templaten mukaiset tiedostot
dotnet new classlib -n Domain
 -> tämä loi Domain-kansion ja sinne classlib-templaten mukaiset tiedostot
dotnet new classlib -n Persistence
 -> tämä loi Persistence-kansion ja sinne classlib-templaten mukaiset tiedostot

Lisätään yllä lisätyt projektit solutioniin:
dotnet sln add API
dotnet sln add Application
dotnet sln add Domain
dotnet sln add Persistence

lisätään projektien väliset dependencys
API-kansiossa 
-dotnet add reference ../Application
Application-kansiossa 
-dotnet add reference ../Persistence
-dotnet add reference ../Domain
Persistence-kansiossa
-dotnet add reference ../Domain

kun tämän kansio avataan vs-codessa, pitää luoda tarvittavia asioita.
tätä varten voi tulla popup -> vscode luo kansion .vscode.
jos ei automaattisesti tule niin ajetaan komento (F1) -> .NET:generate assets for build and debug

Debuggausta varten poistettiin API-projektin launcsettings.jsonista https
jotta kehitys mahdollisimman helppoa.
API-projektin käynnistys:
API-kansiossa
-> dotnet run
tai
-> dotnet watch run -> tämä restarttaa automaattisesti jos file muuttuu

nyt defaulttina voidaan mennä selaimella osoitteeseen http://localhost:5000/swagger, koskta
templatessa on tuollainen endpoint määritetty. siellä voi tehdä kyselyn,
joka palauttaa säätietoja


Luotiin luokka "Activity" Domain-kansioon.
Luokalla on propertyja kuten id, title, date, etc.
Luokan propertyistä muodostuu tauluun sarakkeet kun käytetään
entity frameworkkia tietokantataulun muodostukseen.

kun käytetään entity frameworkkia, mahdollistuu se, että kirjoitetaan vain c# eikä
SQL syntaksia. siten on myös helppo vaihtaa SQLitestä toisiin SQL tietokantoihin.

Entity frameform database context tehdään Persistence-kansioon:
asennetaan nuget package Microsoft.entityFrameworkCore.SQLite.
siten luodaan c# luokka DataContext joka inheritoi DbContext, joka taas tulee tuosta entity paketista.
Sitten API-kansion startup-luokassa lisätään datacontext sserviceihin, jotta sitä voi käyttää kaikkialla.
Lisäksi API-kansiossa olevaan appsettings.development.json määritellään 
sql tietokannan connectionstring, joka taas siellä startup luokassa luetaan.

migraation asennus:
pitää olla dotnet-ef asennettuna. asennettu tällä: dotnet tool install --global dotnet-ef
Pitää olla asennettuna API-projektissa nuget package Microsoft.EntityFrameworkCore.Design
sitten luodaan migraation dotnet-ef migrations add initialCreate -p Persistence -s API
Nyt Persistence kansiossa on migrations-kansio

voidaan päivittää tietokanta viimeisimpään migraatioon käyttämällä
detnet ef database -h -komennosta löytyvää update-komentoa.
Nyt kuitenkin halutaan ohjelmallisesti tarkastaa, että kanta päivitetään viimeiseen
migraatioon jos tarvetta on:
-mennään API-namespacen program.cs
-main-methodissa tallennetaan createhostbuilder var host:iin.
  var host = CreateHostBuilder(args).Build();
-Tämän alapuolella using var scope = host.Services.CreateScope();
-tämän alapuolelle  var services = scope.ServiceProvider;
-Näiden jälkeen tuolta services:tä voidaan hakea context (tietokantajuttu) ja ajaa tälle migrate-metodi, joka tarkastaa
tietokannan olemassa olevuuden ja päivitystarpeen:
                //Get the context from the list of services
                var context = services.GetRequiredService<DataContext>();
                //Run the migrations i.e. create database if not exist or update it to the latest migration
                context.Database.Migrate();
Yllä oleva try-catchin sisään, ja jos errori tulee, niin voidaan hakea logger tuolta services-olion sisältä ja logittaa:
                var logger = services.GetRequiredService<ILogger<Program>>();
                //Log the error
                logger.LogError(ex, "An error occured during migration");
            
Kun kaikki yllä mainittu tarkastelu on tehty, lopulta käynnistetään service (host):
-host.Run();

KUN YLLÄ OLEVA MAIN-koodi on valmis, voidaan käynnistää API-program menemällä
API-kansioon ja siellä
-dotnet watch run
-> logituksessa näkyy, että tietokanta luodaan ja sinne systeemitauluja kuten
migrationshistory ja meidän "Activities"-taulu myös

jos on visual studio codessa SQLite-extensio asennettu, voidaan hakea F1-komennosta
SQLite -> open database-komento ja katsoa sisältöä. tuosta avautuu visual studio codeen sivupaneeliin SQLITE explorer,
jossa taulut näkyvissä.

-TESTIDATAN LISÄYS:
-Luotiin uusi luokka Persistence-namespaceen. Luokalla static metodi seeddata joka palauttaa taskin, jossa lisätään
tauluun aktiviteettejä jos activities-taulu on tyhjä.
-lisättiin tämän metodin ajo API-namespacen main-metodissa.huom. lisäys await, niin muutettiin myös main-metodi async-metodiksi.

CONTROLLERIN LUONTI, JOTTA DATA VOIDAAN ANTAA CLIENTILLE
-Katsottiin weatherForecastControllerista mallia, että kaikissa on [ApiController]-attribuutti
ja kaikissa on [Route("api/[controller]")] ([contoller] on placeholder joka korvaantuu luokan nimellä)
attribuutti ja kaikki perityvät ControllerBase-luokasta.
Yllä olevien takia luotiin BaseApiController, jossa yllä mainitut asiat
-ActivitiesController-luokka luotiin
 -> se periytyy yllä mainitusta BaseApiControllerista
 -> sinne luotiin metodit kaikkien activiteettien kysymiseksi ja yksittisen aktiviteetin kysymiseksi.
 -> [HttpGet]-tägin? alle async metodi joka hakee ja palauttaa kaikki aktiviteetit
 -> [HttpGet("{id}")] alle asynk metori joka hakee id.n perusteella kyseisen aktiviteetin tiedost (http:localhost:5000/api/activities/id)


---------------
GIT INIT
---------------
Luodaksemme git repositoryn, ajetaan
-git init
Koska on satoja fileita, jotka luodaan aina uudelleen rebuildissa, ei kannata kaikkien muutoksia tallentaa gittiin
siksipä luodaan dotnet web projekteihin tarkoitettu gitignore-tiedosto ajamalla
-dotnet new gitignore
nyt muutosten määrä laski parista sadasta -> 48
LISÄKSI lisätään gitignoreen myös API -> properties -> appsettings.json, koska siellä
on tuotantoon vientivaiheessa privaatteja tietoja